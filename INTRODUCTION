NewCacheMatters
===============


	这是个比较有趣也有意义的事，作为一个需要应对海量内容数据传输的大型互联网公司，需要一个自己的CDN网络，
而这个网络现在需要一个综合考虑I/O响应速度、支持高并发、适合SATA\SSD存储特点的Cache替换算法，提高现有的缓
存命中率。
	启发我做这件事的是一篇FaceBook实习生工作期间写的论文《An Analysis of Facebook Photo Caching》，文章
透露了一些FB的数据和工作算法的细节，里面重点部分是，将几个Cache替换算法在FB的应用场景下的表现，做对比。
这几个算法是：FIFO, LRU, LFU, S4LRU，以及仅作为比较的“预言家”算法，无穷储存算法。
	在我极力推崇接下来要介绍的“新”算法前，我们先介绍一下上述实验用的算法（它们也被我用于实验比较）。


==================================
-----------------------
☆FIFO：
这是FB，也是我们目前正在使用的算法，先进先出队列，在需要添加访问未命中的数据时，淘汰最先进队列的数
据。
优点：顺序的存储可以极大化使用IO优化算法；不会产生磁盘碎片；
缺点：没有利用数据的热度区分对待，命中率低。

-----------------------
☆LRU: 
维护一个按访问次数排序的优先队列（小顶堆），每次需要淘汰时淘汰队列头部（访问次数最少的）数据。
优点：用上了热度信息，命中率有提高。
缺点：堆内部计数的修改并调整堆，二项堆无法做到，用红黑树可以解决，算法复杂度高/并行时加大锁；随机的淘汰
	  会造成过多的磁盘碎片。
	  
-----------------------
☆LFU: 
维护一个先按访问次数再按访问时间排序的优先队列。
优点：用上更多热度信息，命中率更高。
缺点：实现同LRU，缺点同LRU。

-----------------------
☆S4LRU: 
文章的主要创新点，一个新的业界没使用的方法，文章的浓墨重笔也在这个算法的实验效果上。
实现方法是，将储存空间分为四段，称为cache结构的四层，每一层是独立的一个LRU，新的对象到来时加入到
第一层的队尾，对象命中一次，移动到下一层的队尾处，对于已经在顶层的对象，则移动到本层的队尾；需要
淘汰时，第i层的淘汰，是将队首对象，移动到第i-1层的队尾处，对于已经在第0层的对象，淘汰时则相当于
移出了整个磁盘。
优点： 一个队列的LRU只有队首\尾的机制利用了热度信息，四层的LRU还用所在层数区别热度，实验也证明命中率确实
	   高。
缺点： 同LRU，形成很多磁盘碎片，如果不使用碎片，磁盘空间会减少，使用了碎片，IO读写不连续，效率低。

~~~~~~~~~~~~~~~~~~~~~~~
★预言家算法：
可以计算理论上cache命中率的最高。实际中不能使用的算法。需要知道既有的访问序列，从而得到每次访问对象
的下次访问时间，使得每次淘汰时选到下次访问时间最远的对象。实现时需要一个hash表和一个红黑树。

~~~~~~~~~~~~~~~~~~~~~~~
★无穷储存：
每个对象只在第一次访问会cache miss，由于有无穷的储存空间，之后的访问都会hit，用于表示cache命中率
的极限。

==================================


实验准备：

CDN网络cn184节点，20140402-20140406五天接收到的所有请求，共计7147847694条（71.47亿）。

实验结果：

☆ FIFO
Hit: 	5332866362
Miss: 	1327879454
Total: 	6660745816
FullIt: 487101877
The hit rate is 0.800641

☆ LRU
Hit: 	5480958763
Miss: 	1179787053
Total:	6660745816
FullIt:	487101878
The hit rate is 0.822875

☆ S4LRU
Hit: 	5568470689
Miss: 	1131903166
Total: 	6700373855
FullIt: 447473839
The hit rate is 0.831069

实验是模拟3T储存空间的CDN节点，离线对71亿条访问处理。
为了保证跟线上测试的效果接近，在第一圈写满磁盘前，不统计命中率，实验表明在大约4亿多条请求后，
磁盘写满（FullIt值）。

下面要介绍的算法，如果要介绍优点，可以直接把上述算法所有的缺点复制粘贴过来，作为它所克服的。
先看一下它的实验表现：

☆ 4LazyQueue
Hit: 	5634973350
Miss: 	1187732644
Total:	6822705994
FullIt: 325141699
The hit rate is 0.825915

比IO性能同样优异的FIFO提高了2.5%的命中率，比极致追求命中率而缺点重重的S4LRU低了0.5%的命中率。


接下来描述这个算法，说明其I/O的优越性，并行环境下优越性，并给出线性复杂度证明。

4LazyQueue
4路懒队列算法
{
	维护4路的循环队列，每次对象访问命中时，将该对象的引用计数器+1，不进行其他操作。cache miss时，
	如果第0层队列已经填满，这时候需要淘汰已有对象，将第0层队首淘汰，此时判断，如果该对象的访问计数
	达到了更高层次的”准入阈值“，则将该对象移动至对应层次，如果该层次已满，递归重复本淘汰过程。为了
	避免死循环，高层次降到低层次时，需要修改访问计数以保证它暂时不可能再被提高回高层次。
}

算法动机
{
	“懒”，的思想来自区间数据结构线段树中使用的Lazy propagation技巧，懒操作使得线段树在操作区间的时候
	“用到的信息等用到再计算”，从而每次对任意长的区间操作复杂度都是log(N)。
	
	4路，在物理结构上区分热度，符合SSD/SATA分层结构，也符合内存/磁盘分层结构，并且在实验中表现优异，
	是S4LRU命中率更高的原因。所以这里我们得到借鉴。
	
	循环队列，提供了I/O性能和高并发的优化环境，正如facebook至今还在用简单的FIFO作为cache策略，循环队
	列在工程表现上更好是有道理的。
}
	

IO优越性
{
	LRU和S4LRU，它们每次命中了一个对象后，就勤劳地将它调整到“安全”的位置，不够”懒“，所以造成了
	很多磁盘碎片。在LazyQueue算法中，命中后我们只是将其计数器+1，而不真正及时移动它，因此磁盘碎片
	完全没有产生。由于每次在某一层的加入、删除都在队尾、队首进行，所以IO连续性给高性能IO系统的优化
	算法提供了操作可能。
}

并行环境
{
	区别于LRU每次命中后的调整，懒队列的命中操作只是在单一对象上实现一次++，可以用原子操作实现。
	对于20%的未命中情况，所有调整都在队首队尾加锁执行，不影响其他位置的读取修改等操作，可以让其他
	请求异步非阻塞地使用整个淘汰算法。
}


算法复杂度
{
	命中的时候只需要O(1)的++操作。未命中的时候，会引起一次递归的整体淘汰，最坏情况是，需要淘汰第i层
	时，连续的整层对象都得到了上升的机会，而每个对象需要在对应层次得到位置，引发该层次的淘汰，而该
	层次的淘汰，同样引发了整层对象的上升。递归地影响到所有对象。
	设每个层次的对象数量分别为N0, N1, N2, N3, 每个层次的”准入阈值“为 M0 < M1 < M2 < M3, 最坏情况时
	每个对象的引用计数都达到了最高层的准入阈值 M3，不失一般性，设它们都为M3.
	第一次成功的腾出位置，将是第3层淘汰至第2层时某个对象的M3 -> M3 - 1，当第2层被引用计数=M3 - 1的
	对象填满时，仍然无法满足第3层淘汰下来的位置需要（SIGMA(N_i) > N_2），这时候第2层继续淘汰，淘汰
	时修改引用计数 M3 - 1 -> M2 - 1。同理，仍然需要继续降级并修改引用计数，直到最后四层各个对象的
	引用计数分别为M1 - 1, M2 - 1, M3 - 1, M3时，整个队列稳定下来，所有递归调用结束。
	总体的迁移次数Sum = N0 * 4 + N1 * 3 + N2 * 2 + N3 * 1。
	这次单次淘汰的代价非常大，有多少次会需要这样规模的淘汰？正面计算不容易，需要考虑访问序列不确定性。
	计算引用计数的损失：Cost = N0 * (M3 - M1 + 1) + N1 * (M3 - M2 + 1) + N2 * (M3 - M3 + 1)
	同样考虑最坏情况 M3 = M2 + 1， M2 = M1 +1, M1 = M0 + 1, 
	则Cost = N0 * 3 + N1 * 2 + N2 * 1
	可以神奇地发现，Sum - Cost = N0 + N1 + N2 + N3
	这意味着什么，Cost是执行这次大型迁移的前置活动——进行Cost次命中访问，使得访问计数得到递增，这Cost次
	访问加上1次大迁移，操作复杂度是Sum+Cost，均摊到每次访问，操作复杂度是T = (Sum + Cost)/(Cost +1)，
	使得该复杂度最大化的磁盘空间分配方式是，均分，N0 = N1 = N2 = N3 = X，
	则 T = (6*X + 4*X + 6*X)/(6*X + 1) = 2.66
	也就是说，最坏情况下均摊复杂度是O(1)的。
	
}
	
	

	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
